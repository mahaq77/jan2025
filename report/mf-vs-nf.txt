Key Concepts:Microfrontends:Microfrontends involve breaking a large frontend application into smaller, independent, and self-contained units. Each unit represents a specific feature or part of the UI and can be developed, tested, and deployed independently.Webpack Module Federation:Webpack Module Federation allows multiple JavaScript applications to share code and components with each other. This enables microfrontend architectures, where different applications or modules can dynamically load and run code from other applications at runtime.Native Federation:Native Federation in Angular allows you to utilize Module Federation directly in Angular applications. With the help of Webpack 5 (which Angular supports since version 12), Angular projects can seamlessly integrate microfrontends through dynamic module sharing.




Benefits of Angular Microfrontends with Native Federation:Independence: Teams can independently develop, test, and deploy their microfrontends without impacting other teams.Scalability: It’s easier to scale individual microfrontends independently.Reusability: Shared code can be reused across different microfrontends.Modularization: Complex UIs are broken down into smaller, manageable modules.Challenges:Cross-team Coordination: Even though microfrontends are independent, you need proper communication and standards across teams (e.g., component design, shared services).Versioning: Handling multiple versions of the same microfrontend and ensuring compatibility can be challenging.Performance Overhead: Dynamic loading and sharing of code at runtime can introduce some performance overhead.
Steps to Implement Angular Microfrontends Using Native Federation:Setting Up Angular Projects:You need multiple Angular projects that will act as the microfrontends. You can create separate Angular apps for each microfrontend.Example:app-shell: A container application that loads and orchestrates multiple microfrontends.feature-1: A microfrontend that encapsulates a specific feature.feature-2: Another microfrontend for a different feature.Install Webpack and Module Federation Plugin:You’ll need Webpack 5 and the @angular-architects/module-federation package to configure Module Federation in Angular projects.Install necessary dependencies:ng add @angular-architects/module-federation


Configure Webpack Module Federation:In each of your Angular projects (e.g., app-shell, feature-1, feature-2), you will modify the Webpack configuration to set up module federation.Example for app-shell:javascriptCopy code// webpack.config.jsconst { ModuleFederationPlugin } = require("webpack").container;module.exports = { output: { publicPath: "auto", }, plugins: [ new ModuleFederationPlugin({ name: "app_shell", remotes: { feature_1: "feature_1@http://localhost:4201/remoteEntry.js", feature_2: "feature_2@http://localhost:4202/remoteEntry.js", }, }), ],};Example for feature-1:javascriptCopy code// webpack.config.jsconst { ModuleFederationPlugin } = require("webpack").container;module.exports = { output: { publicPath: "auto", }, plugins: [ new ModuleFederationPlugin({ name: "feature_1", filename: "remoteEntry.js", exposes: { './Feature1Component': './src/app/feature1/feature1.component.ts', }, }), ],};Dynamic Component Loading:In your app-shell (host container app), you can now dynamically load the microfrontends (e.g., feature-1, feature-2) using Angular’s loadRemoteModule function.Example for dynamically loading feature-1 in app-shell:typescriptCopy codeimport { Component } from '@angular/core';import { loadRemoteModule } from '@angular-architects/module-federation';@Component({ selector: 'app-root', template: `<router-outlet></router-outlet>`,})export class AppComponent { constructor() { loadRemoteModule({ remoteEntry: 'http://localhost:4201/remoteEntry.js', remoteName: 'feature_1', exposedModule: './Feature1Component', }).then((m) => { // Use the dynamically loaded module }); }}Routing Integration:For seamless user navigation between microfrontends, Angular’s Router can be used to route requests to different microfrontends based on the user’s interaction.Building and Deploying:Each microfrontend can be built and deployed independently, allowing independent versioning and scaling of different features.The app-shell is responsible for orchestrating the loading of various microfrontends.Run the Applications:Ensure all your microfrontends and the host application are running on different ports (e.g., localhost:4200, localhost:4201, localhost:4202).You may use Angular CLI commands to serve these apps or deploy them to different environments.



Optimizations:Use lazy loading and code splitting to reduce the initial load time.Implement caching and CDN for better performance and reduced load times.
https://github.com/angular-architects/module-federation-plugin/blob/main/libs/native-federation/README.md
Native Federation for AngularNative Federation is a "browser-native" implementation of the successful mental model behind webpack Module Federation for building Micro Frontends (Plugins, etc.).Features Mental Model of Module Federation Future Proof: Uses Web Standards to be independent of build tools like webpack Neat Angular-Integration: Directly delegates to Angular's new ultra-fast esbuild-based ApplicationBuilder to prevent diverging from the Angular standard.More Embraces ESM and Import Maps - an emerging web standard Easy to configure: We use the same API and Schematics as for our Module Federation plugin Blazing Fast: The reference implementation not only uses the fast esbuild; it also caches already built shared dependencies. Supports Angular SSR and Incremental Hydration (since 18@latest)

